# 이것이 안드로이드다 (박성근의 안드로이드 앱 프로그래밍) 요약

http://www.yes24.com/24/Goods/13950202?Acode=101

다음의 내용의 `이것이 안드로이드다 (박성근의 안드로이드 앱 프로그래밍)`을 읽고 주관적으로 간략하게 정리한 내용입니다. 제대로된 학습을 원하신다면 책을 읽을 것을 권장해드립니다.

---

## 1. 시작하기

## 2. 전문가가 추천하는 최적의 개발 환경 구축하기

## 3. 나의 첫 안드로이드 앱 만들기

## 4. 레이아웃의 구성 요소 View와 ViewGroup

## 5. 대표적인 뷰그룹

## 6. 대표적인 뷰

## 7. 자바로 레이아웃 구성하기

---

## 8. 이벤트

* 앱은 `1) 화면을 그리고 2) 사용자 반응`에 동작하는 것이 주 기능이다.
* 화면 터치, 키보드 입력 등과 같은 사용자 이벤트를 앱에서 어떻게 처리하는지를 알아보자.
* 안드로이드는 이벤트 기반으로 프로그래밍을 제공한다.
* 이벤트 기반이란 어떤 사건에 따라 제어 흐름이 결정되어 동작을 처리하는 것을 말한다.
* 폰에서 감지할 수 있는 다양한 입력 장치와 센서들의 입력이 바로 이벤트이다.
* 폰에는 RGB 센서, 홈 센서, 온도/습도 센서, 근접 센서, 제스처 센서, 자이로 센서, 가속도 센서, 지자기 센서, 기압 센서, 터치 센서등의 여러가지 이벤트 장치가 있다.
* 그 중 가장 대표적인 터치와 키 이벤트의 수신 함수, 전달 과정, 리스너에 대해서 알아보자.

### 8.1 터치 이벤트

* 터치 이벤트는 Down, Move, Up 세 가지 이벤트를 감지한다.
* 터치 이벤트의 세 종류는 반드시 시작과 끝이 존재하므로 하나의 단위 간주해야 한다.
* Down -> Move -> Up, Down -> Up 두 종류의 단위로 구분될 수 있다.

#### 8.1.1 터치 이벤트 수신 함수

* 터치 이벤트는 사용자가 화면을 터치 -> 터치 디바이스 드라이버가 이벤트 감지 -> 이벤트 정보를 시스템 서비스인 윈도우 매니저에게 전달 -> 화면에 떠 있는 앱에 최종 전달하게 된다.
* 앱에서 터치 이벤트는 액티비티를 통해 최초 전달되며, 두 가지 함수를 재정의하는 방법으로 이벤트 정보를 받을 수 있다.
* 화면을 터치하면 가장먼저 dispatchTouchEvent 함수가 호출되고 그 다음 onTouchEvent 함수가 호출된다.
* 두 함수 모두 매개 변수로 MotionEvnet 객체 정보를 넘겨준다.

함수명 | 설명
---|---
getAction | 터치 이벤트의 액션값이 전달<br>ACTION_DOWN = 0<br>ACTION_UP = 1<br>ACTION_MOVE = 2<br>ACTION_CANCEL = 3
getX | 이벤트가 발생한 X축 좌표
getY | 이벤트가 발생한 Y축 좌표
getEventTime | 이벤트가 발생한 밀리세컨드 시간<br>부팅한 시점부터 이벤트가 발생한 시점까지
getDownTime | 다운 이벤트가 발생한 밀리세컨드 시간<br>

#### 8.1.2 터치 이벤트 전달 과정

* 액티비티에는 뷰와 뷰그룹이 존재하고 서로 계층 구조를 형성한다.
* 터치이벤트가 해당 뷰까지 전달되는 과정은 다음과 같다.
```txt
1) 터치 이벤트 발생한다. 아직 버튼 뷰까지 이벤트가 전달되지 않았고, 버튼은 자신이 눌렸는지도 모른다.
2) 터치가 발생된 영역에 해당하는 뷰를 최상단 루트 뷰부처 하위로 찾아간다. 각 뷰는 자신의 위치와 크기 정보를 가지므로 탐색이 가능하다.
3) 터치 영역에 해당하는 뷰가 인지하여 터치 영역이 매칭된다. 중요한 점은 사용자가 선택한 버튼의 화면의 가장 상단에 있지만 레이아웃 계층 구조상 가장 하위에 있다는 것이다.
```
* 이벤트를 목표로 하는 뷰에 전달해 주는건 액티비티, 뷰그룹, 뷰 모두의 협업으로 이루어진다.
* 액티비티, 뷰그룹, 뷰 모두 터치 관련 이벤트 함수를 가지고 있고 이 함수들이 목적지까지 이벤트를 배달하는 핵심이 된다.
```txt
1) 터치 이벤트가 발생하면 액티비티의 dispatchTouchEvent 함수가 가장 먼저 호출된다.
2) 액티비티는 터치된 영역의 뷰그룹에게 이벤트를 전달하게 되며 뷰그룹의 dispatchTouchEvent 함수가 호출된다.
3) 뷰그룹은 터치된 영역의 자식 뷰에게 이벤트를 전달하게 되며 뷰의 dispatchTouchEvent 함수가 호출된다.
4) 뷰는 자식뷰를 가질 수 없으므로 뷰의 dispatchTouchEvent 함수가 호출되었다는 것은 이벤트 전달의 목적지에 도착했다는 의미가 된다.
5) 목적지 뷰의 dispatchTouchEvent 함수는 이벤트를 처리하기 위해 onTouchEvent 함수를 호출한다.
6) 뷰의 onTouchEvent에서는 true, false 값을 반환하여 이벤트 처리의 소비 유무를 결정하면 된다.
7) 뷰가 이벤트를 소비했다면 true를 소비하지 않았다면 false를 반환하면 된다.
8) false를 리턴하게 되면 그 반환값을 받은 뷰의 dispatchTouchEvent 함수도 false를 반환하여 이벤트가 소비되지 않았음을 뷰 그룹에게 알린다.
9) 뷰그룹 역시 뷰가 이벤트를 소비하는 방식으로 동작하게 된다.
10) 만일 뷰그룹 역시 이벤트를 소비하지 않았다면 이벤틀 처리를 위해 액티비티의 onTouchEvent 함수까지 호출하게 된다.
11) 뷰그룹에서 이벤트를 소비하여 true를 반환했다면 dispatchTouchEvent 함수도 true를 반환하여 이벤트 소비를 액티비티에게 알리게 되고 액티비티의 onTouchEvent 함수는 호출되지 않는다.
```
* dispatchTouchEvent는 이벤트를 하위 뷰 혹은 뷰그룹에 전달하는 역할을 하고, onTouchEvent는 이벤트를 소비하는 역할을 한다.
* dispatchTouchEvent는 onTouchEvent보다 먼저 호출되고 onTouchEvent는 호출되지 않을 수도 있다.
```txt
* 뷰그룹과 뷰의 dispatchTouchEvent, onTouchEvent를 재정의 하기 위해 FrameLayout, View를 상속받은 Custom 클래스를 만들었다.
* 액티비티의 dispatchTouchEvent, onTouchEvent는 바로 액티비티에서 재정의 했다.
* 모든 dispatchTouchEvent와 onTouchEvent의 반환값은 super의 동일한 함수를 반환하도록 하였다.
* 로그의 >> 옆의 숫자값은 MotionEvent의 getAction()를 출력하였다.
* 영역별 터치 이벤트 관련 함수와 순서는 아래와 같다.

|----------|-------|-------|      (1) Activity 영역 터치
| View (3) |  (2)  |  (1)  |      Activity dispatchTouchEvent() >> 0
|----------|       |       |      Activity onTouchEvent() >> 0
|                  |       |      (2) ViewGroup 영역 터치
|      ViewGroup   |       |      Activity dispatchTouchEvent() >> 0
|------------------|       |      CustomViewGroup dispatchTouchEvent() >> 0
|                          |      CustomViewGroup onTouchEvent() >> 0
|             Activity     |      Activity onTouchEvent() >> 0
|--------------------------|      (3) View 영역 터치
                                  Activity dispatchTouchEvent() >> 0
                                  CustomViewGroup dispatchTouchEvent() >> 0
                                  CustomView dipatchTouchEvent >> 0
                                  CustomView onTouchEvent >> 0
                                  CustomViewGroup onTouchEvent >> 0
                                  Activity onTouchEvent() >> 0
```
* 터치 이벤트 전달과정을 정리하면 다음과 같다.
* Activity (dispatchTouchEvent) -> ViewGroup (dispatchTouchEvent) -> View (dispatchTouchEvent) -> View (onTouchEvent) -> ViewGroup (onTouchEvent) -> Activity (onTouchEvent)
* 특정 뷰에서 이벤트를 처리하고 싶을때는 onTouchEvent 함수를 재정의 하면된다.
* dispatchTouchEvent 함수는 뷰를 탐색해 나가는 기능이지 이벤트를 처리하는 함수는 아니다.
* onTouchEvent 함수를 재정의 했다면 이벤트를 소비할지 상위 뷰에 위임할지 반환값으로 결정해야 한다.

#### 8.1.3 터치 다운 이벤트

#### 8.1.4 onInterceptTouchEvent 함수

#### 8.1.5 requestDisallowInterceptTouchEvent 함수

#### 8.1.6 터치 이벤트 리스너

#### 8.1.7 다양한 터치 이벤트 인터페이스 구현 방법

#### 8.1.8 터치 이벤트 확장

### 8.2 키 이벤트

#### 8.2.1 포커스

#### 8.2.2 포커스 확인 및 이동

#### 8.2.3 포커스 모드

#### 8.2.4 키 이벤트 수신 함수

#### 8.2.5 키 이벤트 전달 과정

#### 8.2.6 키 이벤트 확장

#### 8.2.7 키 이벤트 리스너

### 8.3 마치며

---

## 9. 리소스

## 10. 액티비티 실행과 인텐트

## 11. 액티비티 생명주기

## 12. 태스크

## 13. 액티비티 간 데이터 주고받기

## 14. 안드로이드 프로세스와 스레드

## 15. 브로드캐스트 리시버

## 16. 파일과 데이터베이스

## 17. 콘텐트 프로바이더

## 18. 서비스

---

## 19. 애플리케이션 객체

* 안드로이드 앱은 액티비티, 서비스, 브로드캐스트 리시버, 콘텐트 프로바이더 네가지 컴포넌트로 구성된다.
* 그 컴포넌트 상위에는 익숙하지 않는 객체가 하나 존재하는데 그것이 바로 애플리케이션이다.
* 애플리케이션 객체가 상위에 있다고 하여 컴포넌트를 관리하는 기능을 하는 것은 아니고 클래스 구조상 상속 관계도 아니다.
* 분명한건 애플리케이션 객체는 논리적으로 모든 컴포넌트를 아우르고 각각의 컴포넌트에서 애플리케이션 객체에 자유롭게 접근이 가능하다는 것이다.

### 19.1. 애플리케이션 객체

#### 19.1.1. 애플리케이션 객체의 존재

* 애플리케이션 객체는 매우 익숙한 곳에 존재하고 있다. 바로 AndroidManifest.xml의 application 요소이다.
* application 요소 하위에는 각종 안드로이드 컴포넌트가 포함되고 icon, label, theme 등의 속성이 적용된다.

#### 19.1.2. 애플리케이션 재정의와 생명주기

* 애플리케이션을 상속받아 구현한 후 AndroidManifest.xml에 재정의한 애플리케이션을 사용할 수 있다.
* 재정의시 application 요소의 name 속성에 재정의한 클래스를 참조하도록 수정하면 된다.
* 애플리케이션의 생성과 소멸에 대한 두가지 생명주기 함수는 onCreate, onTerminate이다.
* onTerminate 함수는 BackKey로 앱을 종료했을때 다음번에 다시 해당앱 실행시 빠르게 동작하기 위해 호출되지 않는다.
* 마찬가지로 BackKey로 앱 종료 후 앱 재시작시 처음 앱 실행과는 다르게 애플리케이션 onCreate 함수도 호출되지 않는다.
* 애플리케이션 객체는 앱의 프로세스 그 자체라고 볼 수 있다.
* 애플리케이션의 onCreate 생명주기 함수는 다른 컴포넌트보다 먼저 호출되므로 컴포넌트의 빠른 실행을 위해 최대한 빠르게 반환되어야 한다.

### 19.2. 애플리케이션 객체를 이용한 컴포넌트 간 데이터 공유

* 모든 컴포넌트는 애플리케이션 객체로 접근이 가능하다.
* 특정 컴포넌트에서 애플리케이션 객체에 접근하여 데이터를 저장하고 다른 컴포넌트에서 저장된 객체를 참조할 수 있다.
* 이에 컴포넌트간에 데이터를 주고받는 방법으로 활용될 수 있다.

#### 19.2.1. 액티비티 간 데이터 공유

* 액티비티 간에 데이터를 전달하는 정상적이고 안전한 방법은 인텐트를 사용하여 startActivity, startActivityForResult 함수를 사용하는 것이다.
* 액티비티 수가 많아지고 모든 액티비티가 공통된 정보를 공유해야 한다면 복잡하고 불편한 인텐트를 사용하지 않고 애플리케이션 객체를 이용하여 데이터를 공유할 수 있다.
* A 액티비티에서 애플리케이션 객체를 얻어와 데이터를 저장하고, B 액티비티 onCreate 함수에서 애플리케이션 객체에서 데이터를 가져오게 구현한 후 B 액티비티를 실행하면 정상적으로 데이터를 가져온다.

#### 19.2.2. 다른 컴포넌트 간 데이터 공유

* 서비스(onCreate), 브로드캐스트 리시버(onReceive), 콘텐트 프로바이더(insert)도 각각의 함수에서 애플리케이션 객체에 접근해 정상적으로 데이터를 가져올 수 있다.
* 애플리케이션은 하나의 패키지안에 하나씩만 존재하므로 다른 패키지 컴포넌트에서는 참조가 불가능하다.
* 애플리케이션 객체는 앱 프로세스가 존재하는 동안 종료되지 않으므로 각각의 컴포넌트가 데이터를 저장하기만 하고 종료시점에 데이터를 제거하지 않아 메모리 누수가 발생한다면 OOM에 빠질 수 있으므로 조심히 사용해야 한다.

### 19.3. 애플리케이션의 액티비티 생명주기 콜백 인터페이스

* API 14부터 애플리케이션에 액티비티 생명주기 콜백 인터페이스가 추가되었다.
* 이 콜백 인터페이스를 사용하면 패키지에 포함된 모든 액티비티의 생명주기를 관찰하고 처리할 수 있다.

#### 19.3.1. ActivityLifecycleCallbacks 인터페이스

* 재정의된 애플리케이션 객체에서 ActivityLifecycleCallbacks를 구현하고 onCreate 함수에서 registerActivityLifecycleCallbacks 함수로 등록하면 동작하게 된다.
* 액티비티 생명주기 onCreate, onStart, onResume, onPause, onStop, onDestroy에 대응하여 onActivityCreated, onActivityStarted, onActivityResumed, onActivityStopped, onActivityDestroyed 콜백함수가 호출된다. 

#### 19.3.2. ActivityLifecycleCallbacks를 활용한 앱 종료

* ActivityLifecycleCallbacks를 활용하여 많은 액티비티 스택이 쌓여 있는 상태에서 한번에 앱 종료 기능을 구현할 수 있다. (예제 19-18)
* API 16 젤리빈부터 실행된 모든 액티비티를 한꺼번에 종료하는 Activity.finishAffinity 함수가 추가되어 굳이 ActivityLifecycleCallbacks를 활용할 필요는 없다.

### 19.3. 마치며

* 애플리케이션 객체는 모든 컴포넌트에서 매우 쉽게 접근하여 사용할 수 있다는 큰 장점이 있다.
* 불필요한 데이터까지 저장하여 메모리를 부족해지게 만들고 앱을 느려지게 하지 않도록 주의하자.

---

## 20. 제한된 화면 크기를 극복하기 위한 뷰그룹

## 21. 윈도우
