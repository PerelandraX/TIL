# 이펙티브 자바 2판

http://www.yes24.com/Product/Goods/14283616?scode=032&OzSrank=3ㅁ

다음의 내용은 `이펙티브 자바 2판`을 읽고 주관적으로 간략하게 정리한 내용입니다. 제대로된 학습을 원하신다면 책을 읽을 것을 권장해 드립니다.

---

## 1장 서론

---

## 2장 객체의 생성과 삭제

### 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라

### 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라

---

## 3장 모든 객체의 공통 메서드

### 규칙8 equals를 재정의 할 때는 일반 규약을 따르라

### 규칙9 equals를 재정의 할 때는 반드시 hashCode도 재정의하라

### 규칙10 toString은 항상 재정의하라

---

## 4장 클래스와 인터페이스

### 규칙16 계승하는 대신 구성하라

### 규칙18 추상 클래스 대신 인터페이스를 사용하라

### 규칙19 인터페이스는 자료형을 정의할 때만 사용하라

### 규칙21 전략을 표현하고 싶을 때는 함수 객체를 사용하라

### 규칙22 맴버 클래스는 가능하면 static으로 선언하라

---

## 5장 제네릭

### 규칙25 배열 대신 리스트를 써라

---

## 6장 열거형(enum)과 어노테이션

### 규칙30 int 상수 대신 enum을 사용하라

### 규칙31 ordinal 대신 객체 필드를 사용하라

### 규칙32 비트 필드(bit field) 대신 EnumSet을 사용하라

### 규칙33 ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라

### 규칙34 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라

### 규칙35 작명 패넡 대신 어노테이션을 사용하라

--- 

## 7장 메서드

### 규칙38 인자의 유효성을 검사하라

### 규칙43 null 대신 빈 배열이나 컬렉션을 반환하라

### 규칙44 모든 API 요소에 문서화 주석을 달라

### 규칙46 for 문보다는 for-each 문을 사용하라

* 릴리즈 1.5 이전의 컬렉션, 배열 순회는 다음과 같다.

```java
for (Iterator i = c.iterator(); i.hasNext(); ) {
  doSomething((Element) i.next)); // (1.5 전에는 제네릭이 없었음)
}

for (int i = 0; i < a.length; i++) {
  doSomething(a[i]);
}
```

* 릴리즈 1.5부터 도입된 for-each 문은 성가신 코드를 제거하고 반복자나 첨자변수를 완전히 제거해 오류 가능성을 없앴다.

```java
for (Element e : elements) { // ':' 기호는 "안에 있는(in)"이라고 읽는다.
  doSomething(e);
}

* for-each 문의 장점은 여러 컬렉션을 중첩할때 나타난다.

```java
// 버그가 어디 있는지 알겠는가?
enum Suit { CLUB, DIAMOND, HEART, SPADE }
enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING }
...
Collection<Suit> suits = Arrays.asList(Suit.values());
Collection<Rank> ranks = Arrays.asList(Rank.values());
...
List<Card> deck = new ArrayList<Deck>;
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
  for (Iterator<Rank> j = ranks.iterator(); j.hasNext(): )
    deck.add(new Card(i.next(), j.next())) // i.next는 원래 4번만 반복되길 원했으나 카드숫자별로 한 번씩 호출되어 NoSuchElementException이 발생하고 만다.

// 같은 버그, 다른 증상
enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX }
...
Collection<Face> faces = Arrays.asList(Face.values());
...
for (Iterator<Face> i = faces.iterator(); i.hasNext(); )
  for (Iterator<Face> j = faces.iterator(); j.hasNext(); )
      System.out.println(i.next() + " " + j.next()); // 36개의 조합을 원했으나 6개만 출력하고 만다.

// 고치긴 했는데 코드가 보기 싫다 - 이보다는 잘 할 수 있다!
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); ) {
  Suit suit = i.next();
  for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
    deck.add(new Card(suit, j.next()));
}
```

* for-each 문을 중첩하는 간결한 코드로 문제를 해결할 수 있다.

```java
for (Suit suit : suits)
  for (Rank rank : ranks)
    deck.add(new Card(suit, rank));
```

* for-each 문으로 컬렉션, 배열뿐 아니라 Iterable 인터페이스를 구현하는 어떤 객체도 순회할 수 있다.
* Iterable 인터페이스는 구현하기 어렵지 않다. 원소들의 그룹을 나타내는 자료형을 작성할 때는, Collection은 구현하지 않더라도 Iterable은 구현하는게 좋다.
* for-each 문은 전통적인 for 문에 비해 명료하고 버그 발생 가능성도 적으로 성능도 for 문에 뒤지지 않는다.
* for-each 문을 적용할 수 없는 경우를 제외하고 가능하다면 항상 for문 대신 for-each문을 사용해야 한다. (아래의 경우는 for 문을 사용하되, 여러 문제들을 회피하도록 해야 한다)
  * 필터링 - 컬렉션을 순회하다가 특정한 원소를 삭제할 필요가 있는 경우
  * 변환 - 리스트나 배열을 순회하다가 그 원소 가운데 일부 또는 전부의 값을 변경할 필요가 있는 경우
  * 병렬 순회 - 여러 컬렉션을 병렬적으로 순회해야 하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 할 필요가 있는 경우

---

## 8장 일반적인 프로그래밍 원칙들

### 규칙49 객체화된 기본 자료형 대신 기본 자료형을 이용하라

### 규칙52 객체를 참조할 때는 그 인터페이스를 사용하라

### 규칙56 일반적으로 톹용되는 작명 습관을 따르라

---

## 9장 예외

### 규칙57 예외는 예외적 상황에만 사용하라

### 규칙60 표준 예외를 사용하라

### 규칙61 추산화 수준에 맞는 예외를 던져라

### 규칙62 메서드에서 전져지는 모든 예외에 대해 문서를 남겨라

---

## 10장 병행성

### 규칙66 변경 가능 공유 데이터에 대한 접근은 동기화하라

### 규칙68 스레드보다는 실행자와 태스크를 이용하라

### 규칙69 wait나 notify 대신 병행성 유틸리티를 이용하라

---

## 11장 직렬화

### 규칙78 직렬화된 객체 대신 직렬화 프락시를 고려해 보라vvvvbvvvb bcccccccccccccccccccccccccccccccccccccx
